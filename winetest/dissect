#!/usr/bin/perl -w
#
# Searches for $queuedir/rep*/report.txt-s, preprocesses and moves
# them into the appropriate $datadir/build/version directories, and
# creates $datadir/build/outdated. Each generated file has .txt extension.
#
# Files: winetest.conf
#
# Exit: 0 - successfully processed a report, call again
#       1 - failure processing a report, call again
#       2 - there was nothing to do
#       3 - fatal error, something went utterly wrong
#
# Copyright (C) 2004 Ferenc Wagner
#
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# License as published by the Free Software Foundation; either
# version 2.1 of the License, or (at your option) any later version.
#
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this library; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

use strict;
use vars qw/$gitdir $queuedir $datadir $maxmult $maxfilesize/;
require "winetest.conf";

my $name0=$0;
$name0 =~ s+^.*/++;

# We support reports version 3 and up
my $minimum_report_version=3;
# And we generate summary files version 4
my $summary_version=4;


use File::Temp qw/tempdir/;
use Errno qw/ENOTEMPTY/;

$ENV{GIT_DIR} = $gitdir;

my ($report, $tmpdir);

sub mydie(@) {
    my $errdir = tempdir ("errXXXXX", DIR => $queuedir);
    if (!rename $tmpdir, $errdir) {
        print STDERR "$name0:error: unable to rename '$tmpdir' to '$errdir': $!\n";
        exit 3;
    }
    if (open ERR, ">$errdir/error")
    {
        print ERR "$name0:error:$errdir: ", @_;
        close ERR;
    }
    print STDERR "$name0:error:$errdir: ", @_;
    exit 1;
}

($report,undef) = glob "$queuedir/rep*/report";
exit 2 unless defined $report;

($tmpdir = $report) =~ s|^(.+)/report$|$1|;
my $tmpfile = "$tmpdir/dissect.tmp";

open IN, "<:raw", $report or mydie "unable to open '$report' for reading: $!\n";
open SUM, ">$tmpdir/summary.txt" or mydie "unable to open '$tmpdir/summary.txt' for writing: $!\n";

# Get the size of the report file
my $filesize = -s "$report";

$_ = <IN>;
/^Version (\d+)\r?$/ or mydie "no version header: $_";
mydie "illegal version: $1\n" if ($1 lt $minimum_report_version);
print SUM "Version $summary_version\n";

$_ = <IN>;
/^Tests from build ([-.0-9a-zA-Z]+)\r?$/ or mydie "no build header: $_";
my $testbuild = $1;
$testbuild =~ /^[0-9a-f]{40}$/ or mydie "not a valid commit id $testbuild\n";
my $commit = `git rev-parse --verify $testbuild^0 2>/dev/null`;
chomp $commit;
$testbuild eq $commit or mydie "not an existing commit $testbuild\n";

$_ = <IN>;
/^Archive: (.*?)\r?$/ or mydie "no archive line: $_";
print SUM "Archive: $1\n";

$_ = <IN>;
/^Tag: ([-.0-9a-zA-Z]*)\r?$/ or mydie "no tag line: $_";
my $tag = $1 eq ""?"":"_$1";

$_ = <IN>;
/^Build info:\r?$/ or mydie "no Build info header: $_";
open BINFO, ">$tmpdir/build.txt" or mydie "unable to open '$tmpdir/build.txt' for writing: $!\n";
while (($_ = <IN>) =~ s/^    //) { print BINFO; }
close BINFO or mydie "error writing to '$tmpdir/build.txt': $!\n";

my ($wine, $version, $major, $minor, $plid);
/^Operating system version:\r?$/ or mydie "no OS header: $_";
open OSVER, ">$tmpdir/version.txt" or mydie "unable to open '$tmpdir/version.txt' for writing: $!\n";
while (($_ = <IN>) =~ /^\s*([0-9a-zA-Z ]+)=(.*?)\r?$/) {
    print OSVER "$1=$2\n";
    if      ($1 eq "bRunningUnderWine") {
        $wine = $2;
    } elsif ($1 eq "dwMajorVersion") {
        $major = $2;
    } elsif ($1 eq "dwMinorVersion") {
        $minor = $2;
    } elsif ($1 eq "PlatformId") {
        $plid = $2;
    }
}
close OSVER or mydie "error writing to '$tmpdir/version.txt': $!\n";

$version = "unknown";
if ($plid==1 && $major==4) {
    if      ($minor==0) {
        $version = "95";
    } elsif ($minor==10) {
        $version = "98";
    } elsif ($minor==90) {
        $version = "me";
    }
} elsif ($plid==2) {
    if      ($major==3 && $minor==51) {
        $version = "nt3";
    } elsif ($major==4 && $minor== 0) {
        $version = "nt4";
    } elsif ($major==5) {
        if      ($minor==0) {
            $version = "2000";
        } elsif ($minor==1) {
            $version = "xp";
        } elsif ($minor==2) {
            $version = "2003";
        }
    } elsif ($major==6) {
        $version = "vista";
    }
} elsif ($plid==3) {
    $version = "ce$major$minor";
}
if ($wine) {
    $tag = "_$version$tag";
    $version = "wine";
}

# Dll information is only available in new type reports
my %dllinfo;
chomp;
if (/^Dll info:\r?$/) {
    while ($_ = <IN>) {
        chomp;
        last if (!/^\s+([^ =]+)=(.*)\r?$/);
        $dllinfo{$1}=$2;
    }
}

/^Test output:/ or mydie "no test header: $_";
my ($dll, $unit, $source, $rev, $result);
my ($lines,$total, $todo, $failed, $skipped);
$dll = undef;                   # state machine starts
$total = $todo = $failed = $skipped = 0;
$lines = 0;
while (<IN>) {
    if (!defined $dll) {        # new test
        next if /^\s*$/;
        m[([_.a-z0-9]+):([_a-z0-9]+) start ([/_.a-z0-9]+) (-|[.0-9a-f]+)\r?$]
          or next;
        ($dll,$unit,$source,$rev) = ($1,$2,$3,$4);
        open OUT, ">:raw", $tmpfile or mydie "unable to open '$tmpfile' for writing: $!\n";
        print OUT;
    } elsif (/^(.*$unit.*: (\d+) tests executed \((\d+) marked as todo, (\d+) failures?\), (\d+) skipped\.)\r?$/) {
        $lines++;
        $total += $2;
        $todo += $3;
        $failed += $4;
        $skipped += $5;
        print OUT;
    } elsif (/^(.*$unit.*: (\d+) tests executed, (\d+) marked as todo, (\d+) failures?\.)\r?$/) {
        # We find these lines in report version 3 files
        $lines++;
        $total += $2;
        $todo += $3;
        $failed += $4;
        print OUT;
    } elsif (/^.*$unit.*: Tests skipped: (?:$dll(?:\.dll)? cannot be loaded|$dll(?:\.dll)? not found|Could not load $dll(?:\.dll)?)\r?$/) {
        # We find these lines in report version 3 files
        $dllinfo{$dll}="dll is missing";
        print OUT;
    } elsif (/^.*$unit.*:Could not load $dll/) {
        # We find these lines in report version 3 files
        $dllinfo{$dll}="dll is missing";
        print OUT;
    } elsif (/$dll:$unit done \((-?\d+)\)\r?$/) {
        chomp;                  # current test ended
        if ($lines==0) {
            $result = "failed $1 - -";
        } else {
            $result = "$total $todo $failed $skipped";
        }
      FINISH:
        print SUM "- $dll $unit $result $source $rev\n";
        print OUT;
        close OUT or mydie "error writing ot '$tmpfile': $!\n";
        if (-s $tmpfile) {
            my $testfile = "$tmpdir/$dll:$unit.txt";
            rename $tmpfile, $testfile or
              mydie "unable to rename '$tmpfile' to '$testfile': $!\n";
        }
        $dll = undef;
        $total = $todo = $failed = $skipped = 0;
        $lines = 0;
    } else {                    # current test output
        print OUT;
    }
}
if (defined $dll) {
    # Either winetest crashed or the report file was cut off
    $_="";
    if ($filesize == $maxfilesize) {
        $result = "failed filelimit - -";
    } else {
        $result = "failed crash - -";
    }
    goto FINISH;
}
close SUM or mydie "error writing to '$tmpdir/summary.txt': $!\n";
close IN;

if (%dllinfo) {
    open DLLINFO, ">$tmpdir/dllinfo.txt" or mydie "unable to open '$tmpdir/dllinfo.txt' for writing: $!\n";
    foreach my $dll (sort keys %dllinfo) {
        print DLLINFO "$dll=$dllinfo{$dll}\n";
    }
    close DLLINFO or mydie "error writing to '$tmpdir/dllinfo.txt': $!\n";
}

my $builddir = "$datadir/$testbuild";
foreach ($datadir, $builddir) {
    if (!(-d $_ || mkdir $_)) {
        print STDERR "$name0:error: unable to create the '$_' directory: $!\n";
        exit 3;
    }
}

my ($dir, $dirbase, $try);
$dir = $dirbase = "$builddir/$version$tag";
$try = 0;
while (!rename $tmpdir, $dir) {
    $!{ENOTEMPTY} or mydie "unable to rename '$tmpdir' to '$dir': $!\n";
    ++$try < $maxmult or mydie "more than $maxmult submissions for $dirbase\n";
    $dir = "${dirbase}_$try";
}
if (!-e "$builddir/outdated") {
    if (!open SIGN, ">$builddir/outdated") {
        print STDERR "$name0:error: unable to open '$builddir/outdated' for writing: $!\n";
        exit 1;
    }
    close SIGN;
}
