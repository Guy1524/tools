#!/usr/bin/perl
#
# Copyright (C) 2004 Ferenc Wagner
# Copyright (C) 2008 Alexandre Julliard
#
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# License as published by the Free Software Foundation; either
# version 2.1 of the License, or (at your option) any later version.
#
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this library; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#
# This program looks for a WineTest report file matching $queuedir/rep*/report,
# takes it apart in its directory while also creating summary.txt. If an error
# occurs the directory is renamed to errXXXXX to avoid future attempts at
# processing this report.
# If everything goes flawlessly the whole directory is renamed (based on the
# information learned in the process) to $datadir/BUILD/VERSION_TAG_DIGIT
# where DIGIT is for resolving name clashes and $datadir/BUILD/outdated is
# created to signal the change in the given build.
#
# Exit: 0 - successfully processed a report, call again
#       1 - failed to process a report, call again
#       2 - there was nothing to do
#       3 - fatal error, something went utterly wrong

use strict;
use warnings;

use open ':utf8';
use CGI qw(:standard);
charset("utf-8");

sub BEGIN
{
    if ($0 !~ m=^/=)
    {
        # Turn $0 into an absolute path so it can safely be used in @INC
        require Cwd;
        $0 = Cwd::cwd() . "/$0";
    }
    unshift @INC, $1 if ($0 =~ m=^(/.*)/[^/]+$=);
}
use vars qw/$gitdir $gitweb $queuedir $datadir $maxmult $maxuserskips $maxfailedtests $maxfilesize $acceptprediluvianwin/;
require "winetest.conf";

my $name0=$0;
$name0 =~ s+^.*/++;

# We support reports version 4 and up
my $minimum_report_version=4;
# And we generate summary files version 4
my $summary_version=4;


use File::Temp qw/tempdir/;
use Errno qw/ENOTEMPTY/;

$ENV{GIT_DIR} = $gitdir;

my ($report, $tmpdir, $tag);

sub mydie(@) {
    my $errdir = tempdir ("errXXXXX", DIR => $queuedir);
    if (!rename $tmpdir, $errdir) {
        print STDERR "$name0:error: unable to rename '$tmpdir' to '$errdir': $!\n";
        exit 3;
    }
    my $label = $tag ? $tag : "<notag>";
    if (open ERR, ">$errdir/error")
    {
        print ERR "$label: ", @_;
        close ERR;
    }
    print STDERR "$name0:error:$label: ", @_;
    exit 1;
}

my @boxes;

sub create_box($$$)
{
    my ($id, $class, $title) = @_;
    my $box = { id => $id, class => $class, title => $title, data => "" };
    push @boxes, $box;
    return $box;
}

($report, undef) = glob "$queuedir/rep*/report";
exit 2 unless defined $report;

($tmpdir = $report) =~ s|^(.+)/report$|$1|;

open IN, "<:raw", $report or mydie "unable to open '$report' for reading: $!\n";
open SUM, ">$tmpdir/summary.txt" or mydie "unable to open '$tmpdir/summary.txt' for writing: $!\n";

# Get the size of the report file
my $filesize = -s "$report";

$_ = <IN>;
/^Version (\d+)\r?$/ or mydie "no version header: $_";
mydie "illegal version: $1\n" if ($1 lt $minimum_report_version);
print SUM "Version $summary_version\n";

$_ = <IN>;
/^Tests from build ([-.0-9a-zA-Z]+)\r?$/ or mydie "no build header: $_";
my $testbuild = $1;
$testbuild =~ /^[0-9a-f]{40}$/ or mydie "not a valid commit id $testbuild\n";
my $commit = `git rev-parse --verify $testbuild^0 2>/dev/null`;
chomp $commit;
$testbuild eq $commit or mydie "not an existing commit $testbuild\n";
my $shortbuild = substr($testbuild,0,12);
my $archive = "winetest-$shortbuild.exe";

$_ = <IN>;
if (/^Archive: /) { $_ = <IN>; }  # ignore Archive header

/^Tag: ([-.0-9a-zA-Z]*)\r?$/ or mydie "no tag line: $_";
$tag = $1;

$_ = <IN>;
/^Build info:\r?$/ or mydie "no Build info header: $_";
my $box = create_box( "version", "version", "Version information for $tag" );
$box->{data} .= "<h2>Build version</h2>\n";
$box->{data} .= "<table class=\"output\">\n";
$box->{data} .= "<tr><td>Build</td><td><a title=\"$testbuild\" href=\"$gitweb/?a=shortlog;h=$testbuild\">$shortbuild</a></td></tr>\n";
$box->{data} .= "<tr><td>Tag</td><td><a title=\"Full report\" href=\"report.html\">$tag</a></td></tr></table>\n";
$box->{data} .= "<div class=\"output\"> </div>\n";
while (($_ = <IN>) =~ s/^    //)
{
    chomp;
    s/\r+$//;
    $box->{data} .= "<div class=\"output\">" . escapeHTML($_) . "</div>\n";
}

my ($wine, $wine_build, $major, $minor, $plid, $product, $host);
/^Operating system version:\r?$/ or mydie "no OS header: $_";
$box->{data} .= "<h2>Operating system version</h2>\n";
$box->{data} .= "<table class=\"output\">\n";
while (($_ = <IN>) =~ /^\s*([0-9a-zA-Z ]+)=(.*?)\r?$/) {
    if ($1 eq "URL") {
        $box->{data} .= sprintf "<tr><td>$1</td><td><a href=\"%s\">%s</a></td></tr>\n", escapeHTML($2), escapeHTML($2);
    } else {
        $box->{data} .= sprintf "<tr><td>$1</td><td>%s</td></tr>\n", escapeHTML($2);
    }
    if      ($1 eq "bRunningUnderWine") {
        $wine = $2;
    } elsif ($1 eq "dwMajorVersion") {
        $major = $2;
    } elsif ($1 eq "dwMinorVersion") {
        $minor = $2;
    } elsif ($1 eq "PlatformId") {
        $plid = $2;
    } elsif ($1 eq "wProductType") {
        $product = $2;
    } elsif ($1 eq "WineBuild") {
        $wine_build = $2;
    } elsif ($1 eq "Platform") {
        $archive = "winetest64-$shortbuild.exe" if ($2 eq "x86_64");
    } elsif ($1 eq "Host system") {
        $host = $2;
    }
}
$box->{data} .= "</table>\n";

my @idmatch = (
    # Describes how to match a platform's version information
    # with a dissect platform id:
    # dissect id  plid  major  minor  product  prediluvian
    [ "95",          1,     4,     0,  undef,  1 ],
    [ "98",          1,     4,    10,  undef,  1 ],
    [ "me",          1,     4,    90,  undef,  1 ],
    [ "nt3",         2,     3,    51,  undef,  1 ],
    [ "2000",        2,     5,     0,  undef,  1 ],
    [ "xp",          2,     5,     1,      1,  0 ],
    [ "2003",        2,     5,     1,  undef,  0 ],
    [ "vista",       2,     6,     0,      1,  0 ],
    [ "2008",        2,     6,     0,      3,  0 ],
    [ "win7",        2,     6,     1,      1,  0 ],
    [ "2008",        2,     6,     1,      3,  0 ],
    [ "win8",        2,     6,     2,  undef,  0 ],
    [ "win8",        2,     6,     3,  undef,  0 ],
    [ "win10",       2,    10,     1,  undef,  0 ],
#   [ "ce",          3, undef, undef,  undef,  0 ],
    [ "unknown",     2, undef, undef,  undef,  0 ],
    [ "unknown", undef, undef, undef,  undef,  1 ],
);

my ($version, $prediluvian);
foreach my $entry (@idmatch)
{
    if ((!defined $entry->[1] or $entry->[1] eq $plid) and
        (!defined $entry->[2] or $entry->[2] eq $major) and
        (!defined $entry->[3] or $entry->[3] eq $minor) and
        (!defined $entry->[4] or $entry->[4] eq $product))
    {
        $version = $entry->[0];
        $prediluvian = $entry->[5];
        last;
    }
}

if ($prediluvian and not $acceptprediluvianwin)
{
    mydie "platform $version (platform $plid, type $product, $major.$minor) not accepted";
}

if ($wine) {
    my %known_hosts = ( "Linux" => "linux",
                        "Darwin" => "mac",
                        "FreeBSD" => "bsd",
                        "SunOS" => "solaris" );
    $version = $host && defined($known_hosts{$host}) ? $known_hosts{$host} : "wine";
}
if ($wine_build) {
    my $wine_commit;
    if ($wine_build =~ /-g([0-9a-f]+)$/)
    {
        $wine_commit = `git rev-parse --verify $1^0 2>/dev/null`;
    }
    elsif ($wine_build =~ /^[-+._0-9A-Za-z]+$/)
    {
        $wine_commit = `git rev-parse --verify $wine_build^0 2>/dev/null`;
    }
    else
    {
        mydie "invalid wine build '$wine_build'\n";
    }
    chomp $wine_commit;
    mydie "unknown wine build '$wine_build'\n" unless $wine_commit;
    my $merge_base = `git merge-base $wine_commit $testbuild 2>/dev/null`;
    chomp $merge_base;
    $merge_base eq $testbuild or mydie "wine build '$wine_build' not a descendant of build $testbuild\n";
}

my $user_skips = 0;
my $failed_tests = 0;
my %dllinfo;
/^Dll info:\r?$/ or mydie "no Dll info header: $_";
$box->{data} .= "<h2>DLL version</h2>\n";
while ($_ = <IN>) {
    chomp;
    s/\r+$//;
    last if (!/^\s+([^ =]+)=(.*)\r?$/);
    my $module = $1;
    $dllinfo{$module} = { version => $2 };
    if ($2 eq "dll is missing" || $2 =~ /^load error/ || $2 eq "dll is a stub")
    {
        print SUM "- $module - missing - - - - -\n";
    }
    elsif ($2 eq "skipped")
    {
        print SUM "- $module - skipped - - - - -\n";
        mydie "too many dlls skipped by user request\n" if ++$user_skips > $maxuserskips;
    }
}

/^Test output:/ or mydie "no test header: $_";
my ($dll, $unit, $source, $rev, $result);
my ($lines,$total, $todo, $failed, $skipped);
$dll = undef;                   # state machine starts
$total = $todo = $failed = $skipped = 0;
$lines = 0;
my $testbox;
while (<IN>) {
    if (!defined $dll) {        # new test
        next if /^\s*$/;
        m[([_.a-z0-9]+):([_a-z0-9]+) (start|skipped) ([/_.a-z0-9]+) (-|[.0-9a-f]+)\r?$]
          or next;
        ($dll,$unit,$source,$rev) = ($1,$2,$4,$5);
        $testbox = create_box( "$dll:$unit", "testfile", "<a href=\"$gitweb/?a=history;f=$source;hb=$testbuild\">$source</a>" );
        if (defined($dllinfo{$dll}->{version}) && !defined($dllinfo{$dll}->{first}))
        {
            $dllinfo{$dll}->{first} = "$dll:$unit";
        }
        if ($3 eq "skipped")
        {
            $testbox->{data} .= "<div class=\"test result skipped\">Skipped by user request.</div>\n";
            print SUM "- $dll $unit skipped - - - $source $rev\n";
            $dll = undef;
            mydie "too many tests skipped by user request\n" if ++$user_skips > $maxuserskips;
        }
    } elsif (/^((?:[0-9a-f]+:)?$unit: (\d+) tests executed \((\d+) marked as todo, (\d+) failures?\), (\d+) skipped\.)\r?$/) {
        $lines++;
        $total += $2;
        $todo += $3;
        $failed += $4;
        $skipped += $5;
        chomp;
        s/\r+$//;
        my $class = "test result";
        if ($failed) { $class .= " failed"; }
        elsif ($todo) { $class .= " todo"; }
        $testbox->{data} .= sprintf "<div class=\"%s\">%s</div>\n", $class, escapeHTML($_);
    } elsif (/$dll:$unit(?::[0-9a-f]+)? done \((-?\d+)\)(?:\r?$| in)/) {
        chomp;                  # current test ended
        if ($lines==0 || $1 < 0) {
            $result = "failed $1 - -";
            my $reason = "test failed: error $1";
            if ($1 == 258) { $reason = "test failed: timed out"; }
            elsif ($1 < 0) { $reason = "test failed: crash"; }
            $testbox->{data} .= "<div class=\"test end\">$reason</div>\n";
            mydie "too many test failures\n" if ++$failed_tests > $maxfailedtests;
        } else {
            $result = "$total $todo $failed $skipped";
            if ($failed) { mydie "too many test failures\n" if ++$failed_tests > $maxfailedtests; }
        }
        print SUM "- $dll $unit $result $source $rev\n";
        $dll = undef;
        $total = $todo = $failed = $skipped = 0;
        $lines = 0;
    } else {                    # current test output
        chomp;
        s/\r+$//;
        if (/^$unit\.c:(\d+): (.*)$/)
        {
            my ($line, $text) = ($1, $2);
            my $class = "test trace";
            if ($text =~ /^Test failed: /) { $class = "test failed"; }
            elsif ($text =~ /^Test succeeded inside todo block: /) { $class = "test failed"; }
            elsif ($text =~ /^Test marked todo: /) { $class = "test todo"; }
            elsif ($text =~ /^Tests skipped: /) { $class = "test skipped"; }
            $testbox->{data} .= sprintf "<div class=\"%s\"><a href=\"%s/?a=blob;f=%s;hb=%s#l%u\">%s.c:%u</a>: %s</div>\n",
                                 $class, $gitweb, $source, $testbuild, $line, $unit, $line, escapeHTML($text);
        }
        else
        {
            $testbox->{data} .= sprintf "<div class=\"test trace\">%s</div>\n", escapeHTML($_);
        }
    }
}
if (defined $dll) {
    # Either winetest crashed or the report file was cut off
    if ($filesize == $maxfilesize) {
        mydie "report reached file limit (runaway test?)\n";
    } else {
        mydie "report truncated (winetest crash?)\n";
    }
}
close SUM or mydie "error writing to '$tmpdir/summary.txt': $!\n";
close IN;

# fill the dllinfo box

$box->{data} .= "<table class=\"output\">\n";
foreach my $dll (sort keys %dllinfo)
{
    if ($dllinfo{$dll}->{version} eq "dll is missing")
    {
        $box->{data} .= sprintf "<tr><td>%s</td><td class=\"skipped\">missing</td></tr>\n", escapeHTML($dll);
    }
    elsif ($dllinfo{$dll}->{version} eq "skipped")
    {
        $box->{data} .= sprintf "<tr><td>%s</td><td class=\"skipped\">skipped by user request</td></tr>\n", escapeHTML($dll);
    }
    elsif ($dllinfo{$dll}->{version} eq "load error 1157")
    {
        $box->{data} .= sprintf "<tr><td>%s</td><td class=\"skipped\">missing dependencies</td></tr>\n", escapeHTML($dll);
    }
    elsif ($dllinfo{$dll}->{version} eq "dll is a stub")
    {
        $box->{data} .= sprintf "<tr><td>%s</td><td class=\"skipped\">dll is a stub</td></tr>\n", escapeHTML($dll);
    }
    elsif ($dllinfo{$dll}->{version} =~ /^load error/)
    {
        $box->{data} .= sprintf "<tr><td>%s</td><td class=\"failed\">%s</td></tr>\n",
                                   escapeHTML($dll), escapeHTML($dllinfo{$dll}->{version});
    }
    elsif (defined($dllinfo{$dll}->{first}))
    {
        $box->{data} .= sprintf "<tr><td><a href=\"report.html#%s\">%s</a></td><td>%s</td></tr>\n",
                                    escapeHTML($dllinfo{$dll}->{first}), escapeHTML($dll), escapeHTML($dllinfo{$dll}->{version});
    }
    else
    {
        $box->{data} .= sprintf "<tr><td>%s</td><td>%s</td></tr>\n", escapeHTML($dll), escapeHTML($dllinfo{$dll}->{version});
    }
}
$box->{data} .= "</table>";

# add the prev/next links to all the boxes

for (my $i = 0; $i <= $#boxes; $i++)
{
    $boxes[$i]->{prev} = $i > 0 ? $boxes[$i-1]->{id} : "";
    $boxes[$i]->{next} = $boxes[$i+1]->{id} if $i < $#boxes;
}

# create the global report.html file

open REPORT, ">$tmpdir/report.html" or mydie "unable to open '$tmpdir/report.html' for writing: $!\n";

print REPORT start_html( -title => "Wine test run report", -style => {src=>"/report.css"} );
print REPORT "<div class=\"navbar\">";
print REPORT "<a href=\"report\">raw report</a> | <a href=\"..\">summary</a> | <a href=\"../..\">index</a>";
printf REPORT " | <a href=\"/builds/%s\">test binary</a>", escapeHTML($archive) if $archive;
print REPORT "</div>\n";

for (my $i = 0; $i <= $#boxes; $i++)
{
    printf REPORT "<div id=\"%s\" class=\"%s\">\n", $boxes[$i]->{id}, $boxes[$i]->{class};
    printf REPORT "<div class=\"updownbar\"><table><tr><td width=\"100%%\">%s</td>\n", $boxes[$i]->{title};
    printf REPORT "<td class=\"arrow\"><a href=\"#%s\">&uarr;</a></td>\n", $boxes[$i]->{prev} if defined $boxes[$i]->{prev};
    printf REPORT "<td class=\"arrow\"><a href=\"#%s\">&darr;</a></td>\n", $boxes[$i]->{next} if defined $boxes[$i]->{next};
    print REPORT "</tr></table></div>\n";
    print REPORT $boxes[$i]->{data}, "</div>\n";
}
print REPORT end_html();
close REPORT or mydie "error writing to '$tmpdir/report.html': $!\n";

# create individual html files for all boxes

for (my $i = 0; $i <= $#boxes; $i++)
{
    open FILE, ">$tmpdir/$boxes[$i]->{id}.html" or mydie "unable to open '$tmpdir/$boxes[$i]->{id}.html' for writing: $!\n";
    print FILE start_html( -title => "Wine test run report", -style => {src=>"/report.css"} );
    print FILE "<div class=\"navbar\">";
    print FILE $boxes[$i]->{prev} ? "<a href=\"./$boxes[$i]->{prev}.html\">prev</a> | " : "prev | ";
    print FILE $boxes[$i]->{next} ? "<a href=\"./$boxes[$i]->{next}.html\">next</a> | " : "next | ";
    print FILE "<a href=\"version.html\">info</a> | ";
    printf FILE "<a href=\"report.html%s\">full report</a> | ", $i ? "#$boxes[$i]->{id}" : "";
    print FILE "<a href=\"report\">raw report</a> | ";
    print FILE "<a href=\"..\">summary</a> | <a href=\"../..\">index</a></div>\n";

    printf FILE "<div id=\"%s\" class=\"%s\">\n", $boxes[$i]->{id}, $boxes[$i]->{class};
    printf FILE "<div class=\"updownbar\">%s</div>\n", $boxes[$i]->{title};
    print FILE $boxes[$i]->{data}, "</div>\n";
    print FILE end_html();
    close FILE or mydie "error writing to '$tmpdir/$boxes[$i]->{id}.html': $!\n";
}

my $builddir = "$datadir/$testbuild";
foreach ($datadir, $builddir) {
    if (!(-d $_ || mkdir $_)) {
        print STDERR "$name0:error: unable to create the '$_' directory: $!\n";
        exit 3;
    }
}

my ($dir, $dirbase, $try);
$dir = $dirbase = "$builddir/${version}_$tag";
$try = 0;
while (!rename $tmpdir, $dir) {
    $!{ENOTEMPTY} or mydie "unable to rename '$tmpdir' to '$dir': $!\n";
    ++$try < $maxmult or mydie "more than $maxmult submissions for $dirbase\n";
    $dir = "${dirbase}_$try";
}
if (!-e "$builddir/outdated") {
    if (!open SIGN, ">$builddir/outdated") {
        print STDERR "$name0:error: unable to open '$builddir/outdated' for writing: $!\n";
        exit 1;
    }
    close SIGN;
}
