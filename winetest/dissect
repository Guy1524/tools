#!/usr/bin/perl -w
#
# Searches for $queuedir/rep*/report.txt-s, preprocesses and moves
# them into the appropriate $datadir/build/version directories, and
# creates $datadir/build/outdated. Each generated file has .txt extension.
#
# Files: winetest.conf
#
# Exit: 0 - successfully processed a report, call again
#       1 - failure processing a report, call again
#       2 - there was nothing to do
#       3 - fatal error, something went utterly wrong
#
# Copyright (C) 2004 Ferenc Wagner
# Copyright (C) 2008 Alexandre Julliard
#
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# License as published by the Free Software Foundation; either
# version 2.1 of the License, or (at your option) any later version.
#
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this library; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

use strict;
use open ':utf8';
use CGI qw(:standard);
charset("utf-8");

use vars qw/$gitdir $gitweb $queuedir $datadir $maxmult $maxfilesize/;
require "winetest.conf";

my $name0=$0;
$name0 =~ s+^.*/++;

# We support reports version 4 and up
my $minimum_report_version=4;
# And we generate summary files version 4
my $summary_version=4;


use File::Temp qw/tempdir/;
use Errno qw/ENOTEMPTY/;

$ENV{GIT_DIR} = $gitdir;

my ($report, $tmpdir);

sub mydie(@) {
    my $errdir = tempdir ("errXXXXX", DIR => $queuedir);
    if (!rename $tmpdir, $errdir) {
        print STDERR "$name0:error: unable to rename '$tmpdir' to '$errdir': $!\n";
        exit 3;
    }
    if (open ERR, ">$errdir/error")
    {
        print ERR "$name0:error:$errdir: ", @_;
        close ERR;
    }
    print STDERR "$name0:error:$errdir: ", @_;
    exit 1;
}

my @boxes;

sub create_box($$$)
{
    my ($id, $class, $title) = @_;
    my $box = { id => $id, class => $class, title => $title, data => "" };
    push @boxes, $box;
    return $box;
}

($report,undef) = glob "$queuedir/rep*/report";
exit 2 unless defined $report;

($tmpdir = $report) =~ s|^(.+)/report$|$1|;

open IN, "<:raw", $report or mydie "unable to open '$report' for reading: $!\n";
open SUM, ">$tmpdir/summary.txt" or mydie "unable to open '$tmpdir/summary.txt' for writing: $!\n";

# Get the size of the report file
my $filesize = -s "$report";

$_ = <IN>;
/^Version (\d+)\r?$/ or mydie "no version header: $_";
mydie "illegal version: $1\n" if ($1 lt $minimum_report_version);
print SUM "Version $summary_version\n";

$_ = <IN>;
/^Tests from build ([-.0-9a-zA-Z]+)\r?$/ or mydie "no build header: $_";
my $testbuild = $1;
$testbuild =~ /^[0-9a-f]{40}$/ or mydie "not a valid commit id $testbuild\n";
my $commit = `git rev-parse --verify $testbuild^0 2>/dev/null`;
chomp $commit;
$testbuild eq $commit or mydie "not an existing commit $testbuild\n";
my $shortbuild = substr($testbuild,0,12);
my $archive = "winetest-$shortbuild.exe";

$_ = <IN>;
if (/^Archive: /) { $_ = <IN>; }  # ignore Archive header

/^Tag: ([-.0-9a-zA-Z]*)\r?$/ or mydie "no tag line: $_";
my $tag = $1 eq ""?"":"_$1";

$_ = <IN>;
/^Build info:\r?$/ or mydie "no Build info header: $_";
my $box = create_box( "version", "version", sprintf "Version information for %s", substr($tag,1) );
$box->{data} .= "<h2>Build version</h2>\n";
$box->{data} .= "<table class=\"output\">\n";
$box->{data} .= sprintf "<tr><td>Build</td><td><a title=\"%s\" href=\"$gitweb/?a=shortlog;h=%s\">%s</a></td></tr>\n", $testbuild, $testbuild, $shortbuild;
$box->{data} .= sprintf "<tr><td>Tag</td><td><a title=\"Full report\" href=\"report.html\">%s</a></td></tr></table>\n", substr($tag,1);
$box->{data} .= sprintf "<div class=\"output\"> </div>\n";
while (($_ = <IN>) =~ s/^    //)
{
    chomp;
    s/\r+$//;
    $box->{data} .= "<div class=\"output\">" . escapeHTML($_) . "</div>\n";
}

my ($wine, $wine_build, $version, $major, $minor, $plid, $product);
/^Operating system version:\r?$/ or mydie "no OS header: $_";
$box->{data} .= "<h2>Operating system version</h2>\n";
$box->{data} .= "<table class=\"output\">\n";
while (($_ = <IN>) =~ /^\s*([0-9a-zA-Z ]+)=(.*?)\r?$/) {
    $box->{data} .= sprintf "<tr><td>$1</td><td>%s</td></tr>\n", escapeHTML($2);
    if      ($1 eq "bRunningUnderWine") {
        $wine = $2;
    } elsif ($1 eq "dwMajorVersion") {
        $major = $2;
    } elsif ($1 eq "dwMinorVersion") {
        $minor = $2;
    } elsif ($1 eq "PlatformId") {
        $plid = $2;
    } elsif ($1 eq "wProductType") {
        $product = $2;
    } elsif ($1 eq "WineBuild") {
        $wine_build = $2;
    } elsif ($1 eq "Platform") {
        $archive = "winetest64-$shortbuild.exe" if ($2 eq "x86_64");
    }
}
$box->{data} .= "</table>\n";

$version = "unknown";
if ($plid==1 && $major==4) {
    if      ($minor==0) {
        $version = "95";
    } elsif ($minor==10) {
        $version = "98";
    } elsif ($minor==90) {
        $version = "me";
    }
} elsif ($plid==2) {
    if      ($major==3 && $minor==51) {
        $version = "nt3";
    } elsif ($major==4 && $minor== 0) {
        $version = "nt4";
    } elsif ($major==5) {
        if      ($minor==0) {
            $version = "2000";
        } elsif ($minor==1) {
            $version = "xp";
        } elsif ($minor==2) {
            $version = "2003";
        }
    } elsif ($major==6 && $minor== 0) {
        if      ($product==1) {
            $version = "vista";
        } elsif ($product==3) {
            $version = "2008";
        }
    } 
} elsif ($plid==3) {
    $version = "ce$major$minor";
}
if ($wine) {
    $version = "wine";
}
if ($wine_build) {
    my $wine_commit;
    if ($wine_build =~ /-g([0-9a-f]+)$/)
    {
        $wine_commit = `git rev-parse --verify $1^0 2>/dev/null`;
    }
    elsif ($wine_build =~ /^[-+._0-9A-Za-z]+$/)
    {
        $wine_commit = `git rev-parse --verify $wine_build^0 2>/dev/null`;
    }
    else
    {
        mydie "invalid wine build '$wine_build'\n";
    }
    chomp $wine_commit;
    mydie "unknown wine build '$wine_build'\n" unless $wine_commit;
    my $merge_base = `git merge-base $wine_commit $testbuild 2>/dev/null`;
    chomp $merge_base;
    $merge_base eq $testbuild or mydie "wine build '$wine_build' not a descendant of build $testbuild\n";
}

my %dllinfo;
/^Dll info:\r?$/ or mydie "no Dll info header: $_";
$box->{data} .= "<h2>DLL version</h2>\n";
while ($_ = <IN>) {
    chomp;
    s/\r+$//;
    last if (!/^\s+([^ =]+)=(.*)\r?$/);
    my $module = $1;
    $dllinfo{$module} = { version => $2 };
    if ($2 eq "dll is missing" || $2 =~ /^load error/)
    {
        print SUM "- $module - missing - - - - -\n";
    }
}

/^Test output:/ or mydie "no test header: $_";
my ($dll, $unit, $source, $rev, $result);
my ($lines,$total, $todo, $failed, $skipped);
$dll = undef;                   # state machine starts
$total = $todo = $failed = $skipped = 0;
$lines = 0;
my $testbox;
while (<IN>) {
    if (!defined $dll) {        # new test
        next if /^\s*$/;
        m[([_.a-z0-9]+):([_a-z0-9]+) start ([/_.a-z0-9]+) (-|[.0-9a-f]+)\r?$]
          or next;
        ($dll,$unit,$source,$rev) = ($1,$2,$3,$4);
        $testbox = create_box( "$dll:$unit", "testfile", "<a href=\"$gitweb/?a=history;f=$source;hb=$testbuild\">$source</a>" );
        if (defined($dllinfo{$dll}->{version}) && !defined($dllinfo{$dll}->{first}))
        {
            $dllinfo{$dll}->{first} = "$dll:$unit";
        }
    } elsif (/^(.*$unit.*: (\d+) tests executed \((\d+) marked as todo, (\d+) failures?\), (\d+) skipped\.)\r?$/) {
        $lines++;
        $total += $2;
        $todo += $3;
        $failed += $4;
        $skipped += $5;
        chomp;
        s/\r+$//;
        my $class = "test result";
        if ($failed) { $class .= " failed"; }
        elsif ($todo) { $class .= " todo"; }
        $testbox->{data} .= sprintf "<div class=\"%s\">%s</div>\n", $class, escapeHTML($_);
    } elsif (/$dll:$unit done \((-?\d+)\)\r?$/) {
        chomp;                  # current test ended
        if ($lines==0 || $1 < 0) {
            $result = "failed $1 - -";
            my $reason = "test failed: error $1";
            if ($1 == 258) { $reason = "test failed: timed out"; }
            elsif ($1 < 0) { $reason = "test failed: crash"; }
            $testbox->{data} .= "<div class=\"test end\">$reason</div>\n";
        } else {
            $result = "$total $todo $failed $skipped";
        }
      FINISH:
        print SUM "- $dll $unit $result $source $rev\n";
        $dll = undef;
        $total = $todo = $failed = $skipped = 0;
        $lines = 0;
    } else {                    # current test output
        chomp;
        s/\r+$//;
        if (/^$unit\.c:(\d+): (.*)$/)
        {
            my ($line, $text) = ($1, $2);
            my $class = "test trace";
            if ($text =~ /^Test failed: /) { $class = "test failed"; }
            elsif ($text =~ /^Test succeeded inside todo block: /) { $class = "test failed"; }
            elsif ($text =~ /^Test marked todo: /) { $class = "test todo"; }
            elsif ($text =~ /^Tests skipped: /) { $class = "test skipped"; }
            $testbox->{data} .= sprintf "<div class=\"%s\"><a href=%s/?a=blob;f=%s;hb=%s#l%u>%s.c:%u</a>: %s</div>\n",
                                 $class, $gitweb, $source, $testbuild, $line, $unit, $line, escapeHTML($text);
        }
        else
        {
            $testbox->{data} .= sprintf "<div class=\"test trace\">%s</div>\n", escapeHTML($_);
        }
    }
}
if (defined $dll) {
    # Either winetest crashed or the report file was cut off
    $_="";
    if ($filesize == $maxfilesize) {
        $result = "failed filelimit - -";
        $testbox->{data} .= "<div class=\"test end\">test failed: file limit exceeded</div>\n";
    } else {
        mydie "report truncated (winetest crash?)\n"; 
    }
    goto FINISH;
}
close SUM or mydie "error writing to '$tmpdir/summary.txt': $!\n";
close IN;

# fill the dllinfo box

$box->{data} .= "<table class=\"output\">\n";
foreach my $dll (sort keys %dllinfo)
{
    if ($dllinfo{$dll}->{version} eq "dll is missing")
    {
        $box->{data} .= sprintf "<tr><td>%s</td><td class=\"skipped\">missing</td></tr>\n", escapeHTML($dll);
    }
    elsif ($dllinfo{$dll}->{version} eq "load error 1157")
    {
        $box->{data} .= sprintf "<tr><td>%s</td><td class=\"skipped\">missing dependencies</td></tr>\n", escapeHTML($dll);
    }
    elsif ($dllinfo{$dll}->{version} =~ /^load error/)
    {
        $box->{data} .= sprintf "<tr><td>%s</td><td class=\"failed\">%s</td></tr>\n",
                                   escapeHTML($dll), escapeHTML($dllinfo{$dll}->{version});
    }
    elsif (defined($dllinfo{$dll}->{first}))
    {
        $box->{data} .= sprintf "<tr><td><a href=\"report.html#%s\">%s</a></td><td>%s</td></tr>\n",
                                    escapeHTML($dllinfo{$dll}->{first}), escapeHTML($dll), escapeHTML($dllinfo{$dll}->{version});
    }
    else
    {
        $box->{data} .= sprintf "<tr><td>%s</td><td>%s</td></tr>\n", escapeHTML($dll), escapeHTML($dllinfo{$dll}->{version});
    }
}
$box->{data} .= "</table>";

# add the prev/next links to all the boxes

for (my $i = 0; $i <= $#boxes; $i++)
{
    $boxes[$i]->{prev} = $i > 0 ? $boxes[$i-1]->{id} : "";
    $boxes[$i]->{next} = $boxes[$i+1]->{id} if $i < $#boxes;
}

# create the global report.html file

open REPORT, ">$tmpdir/report.html" or mydie "unable to open '$tmpdir/report.html' for writing: $!\n";

print REPORT start_html( -title => "Wine test run report", -style => {src=>"/report.css"} );
print REPORT "<div class=\"navbar\">";
print REPORT "<a href=\"report\">raw report</a> | <a href=\"..\">summary</a> | <a href=\"../..\">index</a>";
printf REPORT " | <a href=\"/builds/%s\">test binary</a>", escapeHTML($archive) if $archive;
print REPORT "</div>\n";

for (my $i = 0; $i <= $#boxes; $i++)
{
    printf REPORT "<div id=\"%s\" class=\"%s\">\n", $boxes[$i]->{id}, $boxes[$i]->{class};
    printf REPORT "<div class=\"updownbar\"><table><tr><td width=\"100%%\">%s</td>\n", $boxes[$i]->{title};
    printf REPORT "<td class=\"arrow\"><a href=\"#%s\">&uarr;</a></td>\n", $boxes[$i]->{prev} if defined $boxes[$i]->{prev};
    printf REPORT "<td class=\"arrow\"><a href=\"#%s\">&darr;</a></td>\n", $boxes[$i]->{next} if defined $boxes[$i]->{next};
    printf REPORT "</tr></table></div>\n";
    print REPORT $boxes[$i]->{data}, "</div>\n";
}
print REPORT end_html();
close REPORT or mydie "error writing to '$tmpdir/report.html': $!\n";

# create individual html files for all boxes

for (my $i = 0; $i <= $#boxes; $i++)
{
    open FILE, ">$tmpdir/$boxes[$i]->{id}.html" or mydie "unable to open '$tmpdir/$boxes[$i]->{id}.html' for writing: $!\n";
    print FILE start_html( -title => "Wine test run report", -style => {src=>"/report.css"} );
    print FILE "<div class=\"navbar\">";
    print FILE $boxes[$i]->{prev} ? "<a href=\"./$boxes[$i]->{prev}.html\">prev</a> | " : "prev | ";
    print FILE $boxes[$i]->{next} ? "<a href=\"./$boxes[$i]->{next}.html\">next</a> | " : "next | ";
    printf FILE "<a href=\"report.html%s\">full report</a> | ", $i ? "#$boxes[$i]->{id}" : "";
    print FILE "<a href=\"..\">summary</a> | <a href=\"../..\">index</a></div>\n";

    printf FILE "<div id=\"%s\" class=\"%s\">\n", $boxes[$i]->{id}, $boxes[$i]->{class};
    printf FILE "<div class=\"updownbar\">%s</div>\n", $boxes[$i]->{title};
    print FILE $boxes[$i]->{data}, "</div>\n";
    print FILE end_html();
    close FILE or mydie "error writing to '$tmpdir/$boxes[$i]->{id}.html': $!\n";
}

my $builddir = "$datadir/$testbuild";
foreach ($datadir, $builddir) {
    if (!(-d $_ || mkdir $_)) {
        print STDERR "$name0:error: unable to create the '$_' directory: $!\n";
        exit 3;
    }
}

my ($dir, $dirbase, $try);
$dir = $dirbase = "$builddir/$version$tag";
$try = 0;
while (!rename $tmpdir, $dir) {
    $!{ENOTEMPTY} or mydie "unable to rename '$tmpdir' to '$dir': $!\n";
    ++$try < $maxmult or mydie "more than $maxmult submissions for $dirbase\n";
    $dir = "${dirbase}_$try";
}
if (!-e "$builddir/outdated") {
    if (!open SIGN, ">$builddir/outdated") {
        print STDERR "$name0:error: unable to open '$builddir/outdated' for writing: $!\n";
        exit 1;
    }
    close SIGN;
}
