#!/usr/bin/perl -w
#
# Searches for a $datadir/*/outdated, updates the corresponding
# index.html and removes the outdated.
#
# Files: winetest.conf
#
# Exit: 0 - successfully processed a build, call again
#       1 - should not happen
#       2 - there was nothing to do
#       3 - fatal error, something went utterly wrong
#
# Copyright (C) 2004 Ferenc Wagner
#
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# License as published by the Free Software Foundation; either
# version 2.1 of the License, or (at your option) any later version.
#
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this library; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

use strict;
use vars qw/$datadir/;
require "winetest.conf";

my $name0=$0;
$name0 =~ s+^.*/++;

# We support summary files version 4 and up
my $summary_version=4;


# A test name is of the form 'dll:unit' where:
#  dll           Is the dll being tested.
#  unit          Is a unit test composed of multiple individual checks testing
#                  one aspect of the dll functionality.
#
# Unit test result container:
#
# A unit test result container contains the results of one or multiple runs
# of a given unit test.
#
#  status        A string indicating the status of the result: whether it ran,
#                  crashed, etc.
#  count         The minimum and maximum number of checks performed.
#  errors        The minimum and maximum number of errors.
#  todos         The minimum and maximum number of todos.
#  skips         The minimum and maximum number of skips.
#  omit          If set then this result can be omitted from the group table.
#                  Only used for group results.
#
# Report result containers:
#  tag           The report's tag.
#  dir           The directory containing the report data (log files, etc).
#  group         A reference to the group the report belongs to.
#  dllmissing    A hash of the missing dlls for that system.
#  winetestcrash The name of the last test that was run before winetest
#                  crashed.
#  filelimit     The name of the last test that was run before the report file
#                  size limit was reached.
#  <testname>    Maps the test names to a structure containing the individual
#                  unit test's results. Note that there's no name collision
#                  with the other fields because the test names contain a ':'.
#  errors        The number of unit tests with errors.
#  todos         The number of unit tests with no error but todos.
#
# Group result containers:
#  name          Group name.
#  reports       An array of report result containers.
#  <testname>    Maps the test names to a structure containing the merged
#                  result of the group's reports for that unit test. Note that
#                  there's no name collision with the other fields because the
#                  test names contain a ':'.
#  errors        The number of unit tests with errors.
#  todos         The number of unit tests with no error but todos.

my %w95   = (name => "Win95");
my %w98   = (name => "Win98");
my %me    = (name => "Me");
my %nt3   = (name => "NT3");
my %nt4   = (name => "NT4");
my %w2k   = (name => "2000");
my %xp    = (name => "XP");
my %w2k3  = (name => "2003");
my %vista = (name => "Vista");
my %wine  = (name => "Wine");

# Map dissect's IDs to the above hashes
my %idmap = (95=>\%w95, 98=>\%w98, me=>\%me, nt3=>\%nt3, nt4=>\%nt4,
             2000=>\%w2k, xp=>\%xp, 2003=>\%w2k3, vista=>\%vista, wine=>\%wine);

# Define the order of version groups in the summary
my @groups = (\%w95, \%w98, \%me, \%nt3, \%nt4, \%w2k, \%xp, \%w2k3, \%vista, \%wine);

my ($outdated,undef) = glob "$datadir/*/outdated";
exit 2 unless defined $outdated;
(my $build = $outdated) =~ s|^\Q$datadir\E/(.*)/outdated$|$1|;
(my $release = $build) =~ s/^(\d+).*$/$1/;

# Read in the data

my %alltests;                   # union of test names
my $url;                        # archive url of winetest.exe
foreach my $file (glob "$datadir/$build/*/summary.txt") {
    (my $dir = $file) =~ s|^\Q$datadir/$build\E/(.*?)/summary.txt$|$1|;
    (my $id, my @tag) = split /_/, $dir;
    my $group = $idmap{$id};
    if ($id eq "wine" && defined $tag[0]) {
        $tag[0] = $idmap{$tag[0]}->{name};
        $group = undef unless defined $tag[0]; # make the check below fail
    }
    if (!defined $group) {
        print STDERR "$name0:error: unknown architecture '$id' in '$file'\n";
        next;
    }

    my $report = { group => $group};
    # Read the dll information if present (newer type reports)
    my $dllinfo = "$datadir/$build/$dir/dllinfo.txt";
    if (open DLLINFO, "<$dllinfo") {
        while ($_ = <DLLINFO>) {
            if (/^\s*([0-9a-zA-Z_]+)=(dll is missing)\r?$/) {
                $report->{dllmissing}->{$1} = 1;
            }
        }
        close DLLINFO;
    }
    $report->{tag} = @tag?"@tag":"";
    $report->{dir} = $dir;
    if (!open TEST, "<$file") {
        print STDERR "$name0:error: unable to open '$file' for reading: $!\n";
        next;
    }
    if (($_ = <TEST>) ne "Version $summary_version\n") {
        print STDERR "$name0:error: wrong header in '$file': $_";
        close TEST;
        next;
    }
    if (($url = <TEST>) !~ s/^Archive: (.*)\n$/$1/) {
        print STDERR "$name0:error: wrong archive url in '$file': $url";
        close TEST;
        next;
    }
    while (<TEST>) {
        my ($dummy, $dll, $unit, $count, $todos, $errors, $skips,
            $source, $rev) = split;
        my $testname = "$dll:$unit";

        if ($build =~ /^[0-9a-f]{40}$/) {
		$alltests{$testname} = "http://source.winehq.org/git/wine.git/?a=blob;f=$source;hb=$build"
		    unless exists $alltests{$testname};
        } elsif ($rev =~ /\./) {
		$alltests{$testname} = "http://cvs.winehq.org/cvsweb/wine/$source#rev$rev"
		    unless exists $alltests{$testname};
	} else {
		$alltests{$testname} = "http://source.winehq.org/git/wine.git/?a=blob;f=$source;" .
					($rev ne "-" ? "h=$rev" : "hb=master")
		    unless exists $alltests{$testname};
	}

        # Leave this in for older type reports
        if ($unit =~ /_dll_missing/ or
            ($count eq "0" and exists $report->{dllmissing}->{$dll})) {
            # Mark the dll as missing on this system
            $report->{dllmissing}->{$dll} = 1;
            next;
        }
        if ($count eq "failed") {
            if ($todos eq "crash") {
                $report->{$testname} = { status => "winetest crash" };
                $report->{winetestcrash} = $testname;
            } elsif ($todos eq "filelimit") {
                $report->{$testname} = { status => "file limit" };
                $report->{filelimit} = $testname;
            } else {
                $report->{$testname} = { status => $todos };
            }
        } else {
            $report->{$testname} = { status => "run",
                                     count  => [ $count, $count ],
                                     errors => [ $errors, $errors ],
                                     todos  => [ $todos, $todos ],
                                     skips  => [ $skips, $skips ]
                                   };
        }
        $report->{$testname}->{testname} = $testname;
    }
    close TEST;

    push @{$group->{reports}}, $report;
}

sub merge_min_max($$$)
{
    my ($merged, $result, $field)=@_;
    return if (!exists $result->{$field});

    if (!exists $merged->{$field}) {
        $merged->{$field}=[ @{$result->{$field}} ];
    } else {
        if ($merged->{$field}->[0] > $result->{$field}->[0])
        {
            $merged->{$field}->[0] = $result->{$field}->[0];
        }
        if ($merged->{$field}->[1] < $result->{$field}->[1])
        {
            $merged->{$field}->[1] = $result->{$field}->[1];
        }
    }
}

# Find missing tests. After this exercise all test results (correct, failed
# and missing) are available for all reports.
foreach my $group (@groups) {
    next unless exists $group->{reports};
    $group->{group}=$group;
    foreach my $testname (sort keys %alltests) {
        my $group_result = {};
        foreach my $report (@{$group->{reports}}) {
            if (!exists $report->{$testname}) {
                my ($dll, $unit) = split(/:/, $testname);
                my $crash = $report->{winetestcrash};
                my $filelimit = $report->{filelimit};
                if (exists $report->{dllmissing}->{$dll}) {
                    # Mark this test as missing because of a missing dll
                    $report->{$testname} = { status => "dll missing",
                                             count  => [ 1, 1 ],
                                             skips  => [ 1, 1 ]
                                           };
                } elsif (defined $crash && $testname gt $crash) {
                    # Mark this test as missing because of a winetest crash
                    $report->{$testname}->{status} = "winetest crash";
                } elsif (defined $filelimit && $testname gt $filelimit) {
                    # Mark this test as missing because of a partial report file
                    $report->{$testname}->{status} = "filelimit";
                } else {
                    # Mark this test as missing for an unknown reason
                    $report->{$testname}->{status} = "missing";
                }
            }
            my $result = $report->{$testname};
            if (!defined $group_result->{status}) {
                $group_result->{status} = $result->{status};
            } elsif ($group_result->{status} eq "dll missing" and
                     $result->{status} eq "run") {
                $group_result->{status} = "run";
            } elsif ($group_result->{status} eq "run" and
                     $result->{status} eq "dll missing") {
                ; # Nothing to do
            } elsif ($group_result->{status} ne $result->{status}) {
                $group_result->{status} = "mixed";
            }
            if (defined $result->{count}) {
                merge_min_max($group_result, $result, "count");
                merge_min_max($group_result, $result, "errors");
                merge_min_max($group_result, $result, "todos");
                merge_min_max($group_result, $result, "skips");
            }
        }
        $group->{$testname} = $group_result;
        if ($group_result->{status} eq "dll missing" or
            ($group_result->{status} eq "run" and
             $group_result->{errors}->[1] == 0 and
             $group_result->{todos}->[1] == 0 and
             $group_result->{skips}->[1] == 0))
        {
            # No errors and no todos so we can omit this result
            # from the group table
            $group_result->{omit} = 1;
        }
    }
}

# Compute some statistics

foreach my $group (@groups) {
    next unless exists $group->{reports};
    foreach my $report (@{$group->{reports}}, $group) {
        $report->{errors} = 0;
        $report->{todos} = 0;
        foreach my $testname (sort keys %alltests) {
            my $result = $report->{$testname};
            if ($result->{status} !~ /^(?:dll missing|run)$/ or
                ($result->{status} eq "run" and
                 $result->{errors}->[1] != 0))
            {
                $report->{errors}++;
            }
            elsif ($result->{status} eq "run" and
                   $result->{todos}->[1] != 0)
            {
                $report->{todos}++;
            }
        }
    }
}

# Write out the tables

sub percent($$)
{
    my ($value, $base)=@_;
    return sprintf("%4.1f", 100 * $value / $base);
}

sub build_header_footer($)
{
    my ($reports)=@_;

    my $unit_count=scalar(keys %alltests);
    my ($title, $stats);
    foreach my $rep (@{$reports}) {
        my $report=$rep;
        my $msg;
        if (exists $report->{reports}) {
            my $report_count = @{$report->{reports}};
            if ($report_count > 1) {
                $msg = "        <a href=\"#group_$report->{name}\">$report->{name}<br><small>$report_count reports</small></a>";
            } else {
                $report = $report->{reports}->[0];
            }
        } elsif (exists $report->{name}) {
            # Ignore groups with no reports
            next;
        }
        my $group = $report->{group};

        if (!defined $msg) {
            # If dllinfo.txt exist we use a different layout (new style report)
            if (-r "$datadir/$build/$report->{dir}/dllinfo.txt") {
                $msg = <<"EOF";
        $group->{name}<br><small>
        <a href=\"$report->{dir}/version.txt\">$report->{tag}</a><br>
        <a href=\"$report->{dir}/dllinfo.txt\">[info]</a>
        <a href=\"$report->{dir}/report\">[file]</a></small>
EOF
            } else {
                $msg = <<"EOF";
        $group->{name}<br><small>
        <a href=\"$report->{dir}/build.txt\">$report->{tag}</a><br>
        <a href=\"$report->{dir}/version.txt\">[info]</a>
        <a href=\"$report->{dir}/report\">[file]</a></small>
EOF
            }
            chop $msg;
        }
        $title .=  <<"EOF";
      <th>
$msg
      </th>
EOF

        my $class = $report->{errors} ? "fail" :
                    $report->{todos} ? "todo" :
                    "pass";
        my $count=!$report->{todos} ? $report->{errors} :
                  !$report->{errors} ? $report->{todos} :
                  "$group->{errors}+$group->{todos}";

        my $prcnt=!$report->{todos} ? percent($report->{errors}, $unit_count) :
                  !$report->{errors} ? percent($report->{todos}, $unit_count) :
                  (percent($report->{errors}, $unit_count) . "+" .
                   percent($report->{todos}, $unit_count));
        $stats .= "      <th class=\"$class\"><a title=\"$unit_count unit tests, $report->{errors} have errors, $report->{todos} have todos\">$count<br>$prcnt\%</a></th>\n";
    }
    chop $title;
    chop $stats;
    return <<"EOF";
  <thead>
    <tr>
      <th class="test">platforms</th>
$title
    </tr>
    <tr>
      <th class="test">errors</th>
$stats
    </tr>
  </thead>
  <tfoot>
    <tr>
      <th class="test">errors</th>
$stats
    </tr>
    <tr>
      <th class="test">platforms</th>
$title
    </tr>
  </tfoot>
EOF
}

my $header_footer=build_header_footer(\@groups);

if (!open OUT, ">$datadir/$build/index.html") {
  print STDERR "$name0:error: unable to open '$datadir/$build/index.html' for writing: $!\n";
  goto DONE;
}
print OUT <<"EOF";
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN"
                      "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
  <title>$build</title>
  <link rel="stylesheet" href="/summary.css" type="text/css">

  <meta http-equiv="Content-Type"
        content="text/html; charset=ISO-8859-1">
  <meta name="Author" content="gather">
  <meta http-equiv="Content-Script-Type" content="text/javascript">
</head>

<body>
<table class="navbar">
  <tr>
    <td class="left">
      <a href="/site?testing=prev&amp;current=$build">Previous build</a>
    </td>
    <td><script type="text/javascript" src="/summary.js"></script
        ><noscript><p>JavaScript support missing</p></noscript></td>
    <td class="right">
      <a href="/site?testing=next&amp;current=$build">Next build</a>
    </td>
  </tr>
</table>
<h3>Legend</h3>
<p class="legend">All tests <span class="result pass">pass</span> in all reports<br>
   Some tests <span class="result mixed">fail</span> in some reports<br>
   Some tests <span class="result fail">fail</span> in all reports<br>
   This <span class="result pass also-skip">border</span> signals that some tests are skipped<br>
   This <span class="result pass also-todo">border</span> and this <span class="result todo">background</span> signal that the implementation needs some work
</p>
<h1>Main summary for build <a href="$url">$build</a></h1>
<table class="report">
$header_footer
  <tbody onDblClick="clone();">
EOF

sub min_to_max($)
{
    my ($minmax)=@_;
    return $minmax->[0] if ($minmax->[0] == $minmax->[1]);
    return "$minmax->[0] to $minmax->[1]";
}

# Output a single cell of a test
sub singletest($$$) {
    my ($group, $testname, $groupname) = @_;
    my $result = $group->{$testname};

    my ($href, $label);
    if ($group->{reports} and @{$group->{reports}} > 1)
    {
        $href = $result->{omit} ? "" : "href=\"#group_$groupname:$testname\"";
        $label = $groupname;
    }
    else
    {
        my $report = $group->{reports} ? $group->{reports}->[0] : $group;
        $href = "$report->{dir}/$testname.txt";
        $href = (-r "$datadir/$build/$href") ? "href=\"$href\"" : "";
        $label = "$groupname $report->{tag}";
    }

    my $status = $result->{status};
    if ($status eq "run")
    {
        my $class = $result->{errors}->[0] ? "fail" :
                    $result->{errors}->[1] ? "mixed" :
                    $result->{todos}->[1] ? "todo" :
                    "pass";
        $class .= " also-todo" if ($result->{todos}->[1]);
        $class .= " also-skip" if ($result->{skips}->[1]);
        my $mm_count=min_to_max($result->{count});
        my $mm_errors=min_to_max($result->{errors});
        my $mm_todos=min_to_max($result->{todos});
        my $mm_skips=min_to_max($result->{skips});
        my $title="$mm_count tests, $mm_errors errors, $mm_todos todos, $mm_skips skips";
        my $msg=!$result->{todos}->[1] ? $result->{errors}->[1] :
                !$result->{errors}->[1] ? $result->{todos}->[1] :
                "$result->{errors}->[1]+$result->{todos}->[1]";
        print OUT <<"EOF";
      <td class="result $class"><a $href title="$title"
        onMouseOver="refresh('$testname', '$label', $mm_count, $mm_todos, $mm_errors, $mm_skips);"
        >$msg</a></td>
EOF
    }
    elsif ($status eq "dll missing")
    {
        my ($dll, $unit) = split(/:/, $testname);
        $dll.=".dll" if ($dll !~ /\./);
        print OUT <<"EOF";
      <td class="result pass also-skip"><a $href
        title="No tests run as $dll is not present on this system"
        >n/a</a></td>
EOF
    }
    elsif ($status eq "winetest crash")
    {
        print OUT <<"EOF";
      <td class="note"><a $href
        title="Test did not run as winetest crashed"
        >winetest</a></td>
EOF
    }
    elsif ($status eq "filelimit")
    {
        print OUT <<"EOF";
      <td class="note"><a $href
        title="Test is missing because of a partial report file"
        >truncated</a></td>
EOF
    }
    elsif ($status eq "missing")
    {
        print OUT <<"EOF";
      <td class="note"><a $href
        title="Test did not run for an unknown reason"
        >not run</a></td>
EOF
    }
    elsif ($status eq "mixed")
    {
        print OUT <<"EOF";
      <td class="note"><a $href
        title="Mixed results"
        >mixed</a></td>
EOF
    }
    else
    {
        my $msg = $status eq "crash" ? "crashed" :
                  $status eq "-2" ? "failed" :
                  $status =~ /^-/ ? "crashed" :
                  $status eq "258" ? "timeout": "failed";
        $msg = "<a $href>$msg</a>" if ($href ne "");
        print OUT "      <td class=\"note\">$msg</td>\n";
    }
}

# Create the Main Summary
foreach my $testname (sort keys %alltests) {
    print OUT <<"EOF";
    <tr>
      <td class="test">
        <a href="$alltests{$testname}" title="dll:unit_test source">$testname</a></td>
EOF
    foreach my $group (@groups) {
        if (!exists $group->{reports}) {
            # Do nothing
        } else {
            singletest($group, $testname, $group->{name});
        }
    }
    print OUT "    </tr>\n";
}
print OUT <<"EOF";
  </tbody>
</table>
EOF

# Take the groups with multiple reports
foreach my $group (@groups) {
    next unless exists $group->{reports} && @{$group->{reports}} > 1;

    $header_footer = build_header_footer($group->{reports});

    print OUT <<"EOF";
<hr>
<h2><a name="group_$group->{name}">$group->{name} differences</a></h2>
<table class="report">
$header_footer
  <tbody onDblClick="clone();">
EOF
    foreach my $testname (sort keys %alltests) {
        my $result = $group->{$testname};
        next if ($result->{omit});
        print OUT <<"EOF";
    <tr>
      <td class="test">
        <a href="$alltests{$testname}" name="group_$group->{name}:$testname" title="dll:unit_test source">$testname</a></td>
EOF
        foreach my $report (@{$group->{reports}}) {
            singletest($report, $testname, $group->{name});
        }
    print OUT <<"EOF";
    </tr>
EOF
    }
    print OUT <<"EOF";
  </tbody>
</table>
EOF
}
print OUT <<"EOF";
</body>
</html>
EOF
close OUT;

DONE:
if (!unlink $outdated) {
    print STDERR "$name0:error: unable to unlink '$outdated': $!\n";
    exit 3;
}
