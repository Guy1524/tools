#!/usr/bin/perl -w
#
# This is a testagentd client. It can be used to exchange files or run
# commands on the testagentd server, mostly for testing purposes.
#
# Copyright 2012 Francois Gouget
#
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# License as published by the Free Software Foundation; either
# version 2.1 of the License, or (at your option) any later version.
#
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this library; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA

use strict;

sub BEGIN
{
  if ($0 !~ m=^/=)
  {
    # Turn $0 into an absolute path so it can safely be used in @INC
    require Cwd;
    $0 = Cwd::cwd() . "/$0";
  }
  if ($0 =~ m=^(/.*)/[^/]+/[^/]+$=)
  {
    $::RootDir = $1;
    unshift @INC, "$::RootDir/lib";
  }
  # We normally get $AgentPort from ConfigLocal.pl.
  # But don't fail if it's missing.
  $::BuildEnv = 1 if (!-f "$::RootDir/ConfigLocal.pl");
}

my $name0 = $0;
$name0 =~ s+^.*/++;

use URI;
use WineTestBot::Config;
use WineTestBot::TestAgent;
use WineTestBot::Log;

sub error(@)
{
    print STDERR "$name0:error: ", @_;
}

my ($Cmd, $Hostname, $LocalFilename, $ServerFilename, @Rm);
my (@Run, $RunIn, $RunOut, $RunErr);
my $SendFlags = 0;
my $RunFlags = 0;
my ($Port, $ConnectTimeout, $Timeout, $TunnelOpt);
my $Usage;

sub check_opt_val($$)
{
    my ($option, $val) = @_;

    if (defined $val)
    {
        error("$option can only be specified once\n");
        $Usage = 2; # but continue processing this option
    }
    if (!@ARGV)
    {
        error("missing value for $option\n");
        $Usage = 2;
        return undef;
    }
    return shift @ARGV;
}

while (@ARGV)
{
    my $arg = shift @ARGV;
    if ($arg eq "--help")
    {
        $Usage = 0;
    }
    elsif ($arg eq "--port")
    {
        $Port = check_opt_val($arg, $Port);
    }
    elsif ($arg eq "--connect-timeout")
    {
        $ConnectTimeout = check_opt_val($arg, $ConnectTimeout);
    }
    elsif ($arg eq "--timeout")
    {
        $Timeout = check_opt_val($arg, $Timeout);
    }
    elsif ($arg eq "--tunnel")
    {
        $TunnelOpt = check_opt_val($arg, $TunnelOpt);
    }
    elsif ($arg eq "--sendfile-exe")
    {
        $SendFlags |= $TestAgent::SENDFILE_EXE;
    }
    elsif ($arg eq "--run-no-wait")
    {
        $RunFlags |= $TestAgent::RUN_DNT;
    }
    elsif ($arg eq "--run-in")
    {
        $RunIn = check_opt_val($arg, $RunIn);
    }
    elsif ($arg eq "--run-out")
    {
        $RunOut = check_opt_val($arg, $RunOut);
    }
    elsif ($arg eq "--run-err")
    {
        $RunErr = check_opt_val($arg, $RunErr);
    }
    elsif (!defined $Hostname)
    {
        $Hostname = $arg;
    }
    elsif ($arg eq "sendfile")
    {
        $Cmd = $arg;
        $LocalFilename = check_opt_val($arg, $LocalFilename);
        if (!$Usage)
        {
            if (@ARGV)
            {
                $ServerFilename = check_opt_val($arg, $ServerFilename);
            }
            else
            {
                $ServerFilename = $LocalFilename;
                $ServerFilename =~ s%^.*/%%;
            }
        }
    }
    elsif ($arg eq "getfile")
    {
        $Cmd = $arg;
        $ServerFilename = check_opt_val($arg, $ServerFilename);
        if (!$Usage)
        {
            if (@ARGV)
            {
                $LocalFilename = check_opt_val($arg, $LocalFilename);
            }
            else
            {
                $LocalFilename = $ServerFilename;
                $LocalFilename =~ s%^.*[/\\]%%;
            }
        }
    }
    elsif ($arg eq "run")
    {
        @Run = @ARGV;
        $Cmd = $arg;
        last;
    }
    elsif ($arg eq "rm")
    {
        $Cmd = $arg;
        @Rm = @ARGV;
        last;
    }
    elsif ($arg eq "getversion")
    {
        $Cmd = $arg;
    }
    elsif ($arg eq "ping")
    {
        $Cmd = $arg;
    }
    else
    {
        error("unknown command $arg\n");
        $Usage = 2;
    }
}

if (!defined $Usage)
{
    if (!defined $Cmd)
    {
        error("you must specify a command\n");
        $Usage = 2;
    }
    elsif ($Cmd ne "sendfile" and $SendFlags)
    {
        error("the --sendfile-xxx options can only be used with the sendfile command\n");
        $Usage = 2;
    }
    elsif ($Cmd eq "run" and !@Run)
    {
        error("you must specify the command to run\n");
        $Usage = 2;
    }
    elsif ($Cmd ne "run" and ($RunFlags or defined $RunIn or defined $RunOut or
                           defined $RunErr))
    {
        error("the --run-xxx options can only be used with the run command\n");
        $Usage = 2;
    }
    elsif ($Cmd eq "rm" and !@Rm)
    {
        error("you must specify the server files to delete\n");
        $Usage = 2;
    }
    $AgentPort = $Port if (defined $Port);
    if (!defined $AgentPort)
    {
        error("you must specify the TestAgent port\n");
        $Usage = 2;
    }
    if ($TunnelOpt and $TunnelOpt !~ /^ssh:/)
    {
        error("only SSH tunnels are supported\n");
        $Usage = 2;
    }
}
if (defined $Usage)
{
    if ($Usage)
    {
        error("try '$name0 --help' for more information\n");
        exit $Usage;
    }
    print "Usage: $name0 [options] <hostname> sendfile <localpath> <serverpath>\n";
    print "or     $name0 [options] <hostname> getfile <serverpath> <localpath>\n";
    print "or     $name0 [options] <hostname> run <command> <arguments>\n";
    print "or     $name0 [options] <hostname> rm <serverfiles>\n";
    print "or     $name0 [options] <hostname> [ping|version]\n";
    print "\n";
    print "This is a testagentd client. It can be used to send/receive files and to run commands on the server.\n";
    print "\n";
    print "Where:\n";
    print "  sendfile      Sends the <localpath> file and saves it as <serverpath> on the\n";
    print "                server.\n";
    print "    --sendfile-exe Make the sent file executable.\n";
    print "  getfile       Retrieves the <serverpath> file from the server and saves it\n";
    print "                as <localpath>.\n";
    print "  run           Runs the specified <command> on the server.\n";
    print "    --run-no-wait Don't wait for the command.\n";
    print "    --run-in <serverpath> Redirect the stdin or the command being run to the\n";
    print "                  specified server file.\n";
    print "    --run-out <serverpath> Redirect the stdout or the command being run to the\n";
    print "                  specified server file.\n";
    print "    --run-err <serverpath> Redirect the stderr or the command being run to the\n";
    print "                  specified server file.\n";
    print "  rm            Deletes the specified files on the server.\n";
    print "  getversion    Returns the version of the server.\n";
    print "  ping          Makes sure the server is still alive.\n";
    print "  <hostname>    Is the hostname of the server.\n";
    print "  --port <port> Use the specified port number instead of the default one.\n";
    print "  --connect-timeout <timeout> Use the specified timeout (in seconds) when\n";
    print "                connecting instead of the default one.\n";
    print "  --timeout <timeout> Use the specified timeout (in seconds) instead of the\n";
    print "                default one for the operation.\n";
    print "  --tunnel <uri> Tunnel the connection through ssh. The SSH connection is\n";
    print "                specified in the form of an ssh:// URI.\n";
    print "  --help        Shows this usage message.\n";
    exit 0;
}

$TunnelOpt = $Tunnel if (!defined $TunnelOpt);
my $TunnelInfo;
if ($TunnelOpt)
{
    my $ParsedURI = URI->new($TunnelOpt);
    %$TunnelInfo = %$TunnelDefaults if ($TunnelDefaults);
    $TunnelInfo->{sshhost} = $ParsedURI->host;
    $TunnelInfo->{sshport} = $ParsedURI->port;
    $TunnelInfo->{username} = $ParsedURI->userinfo;
}

my $TA = TestAgent->new($Hostname, $AgentPort, $TunnelInfo);
$TA->SetConnectTimeout($ConnectTimeout) if (defined $ConnectTimeout);
$TA->SetTimeout($Timeout) if (defined $Timeout);

my $RC = 0;
my $Result;
if ($Cmd eq "sendfile")
{
    $Result = $TA->SendFile($LocalFilename, $ServerFilename, $SendFlags);
}
elsif ($Cmd eq "getfile")
{
    $Result = $TA->GetFile($ServerFilename, $LocalFilename);
}
elsif ($Cmd eq "run")
{
    my $Pid = $TA->Run(\@Run, $RunFlags, $RunIn, $RunOut, $RunErr);
    if ($Pid)
    {
        print "Started process $Pid\n";
        if (!($RunFlags & $TestAgent::RUN_DNT))
        {
            $Result = $TA->Wait($Pid);
            print "Child exit status: $Result\n" if (defined $Result);
        }
    }
}
elsif ($Cmd eq "rm")
{
    $Result = $TA->Rm(@Rm);
    if (ref($Result) eq "ARRAY")
    {
        foreach my $Error (@$Result)
        {
            error("$Error\n") if (defined $Error);
        }
        $RC = 1;
    }
    elsif (defined $Result)
    {
        error("$Result\n");
        $RC = 1;
    }
    else
    {
        $Result = 1;
    }
}
elsif ($Cmd eq "getversion")
{
    $Result = $TA->GetVersion();
    print "Version=$Result\n" if (defined $Result);
}
elsif ($Cmd eq "ping")
{
    $Result = $TA->Ping();
    print "The server is alive\n" if ($Result);
}
$TA->Disconnect();

if (!defined $Result)
{
    error($TA->GetLastError() . "\n");
    $RC = 1;
}

exit $RC;
